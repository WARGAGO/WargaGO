import 'package:flutter/foundation.dart';
import '../models/poll_model.dart';
import '../models/poll_option_model.dart';
import '../models/poll_vote_model.dart';
import '../models/poll_result_model.dart';
import '../services/poll_service.dart';
import '../helpers/notification_helper.dart';

/// Provider untuk state management polling
class PollProvider with ChangeNotifier {
  final PollService _pollService = PollService();

  // Loading states
  bool _isLoading = false;
  bool _isSubmittingVote = false;
  bool _isCreatingPoll = false;

  // Error handling
  String? _errorMessage;
  String? _successMessage;

  // Current poll data
  Poll? _currentPoll;
  List<PollOption> _currentOptions = [];
  List<PollVote> _currentVotes = [];
  PollResult? _currentResult;

  // User's vote
  PollVote? _userVote;
  bool _hasUserVoted = false;

  // Lists
  List<Poll> _activeOfficialPolls = [];
  List<Poll> _activeCommunityPolls = [];
  List<Poll> _myPolls = [];
  List<Poll> _pollHistory = [];

  // Getters
  bool get isLoading => _isLoading;
  bool get isSubmittingVote => _isSubmittingVote;
  bool get isCreatingPoll => _isCreatingPoll;
  String? get errorMessage => _errorMessage;
  String? get successMessage => _successMessage;

  Poll? get currentPoll => _currentPoll;
  List<PollOption> get currentOptions => _currentOptions;
  List<PollVote> get currentVotes => _currentVotes;
  PollResult? get currentResult => _currentResult;

  PollVote? get userVote => _userVote;
  bool get hasUserVoted => _hasUserVoted;

  List<Poll> get activeOfficialPolls => _activeOfficialPolls;
  List<Poll> get activeCommunityPolls => _activeCommunityPolls;
  List<Poll> get myPolls => _myPolls;
  List<Poll> get pollHistory => _pollHistory;

  // Get active official poll (untuk home alert)
  Poll? get activeOfficialPoll {
    if (_activeOfficialPolls.isEmpty) return null;
    return _activeOfficialPolls.first;
  }

  int get activeCommunityPollCount => _activeCommunityPolls.length;

  // ===== CREATE OPERATIONS =====

  /// Membuat polling baru dengan opsi
  Future<String?> createPollWithOptions({
    required Poll poll,
    required List<PollOption> options,
  }) async {
    _isCreatingPoll = true;
    _errorMessage = null;
    notifyListeners();

    try {
      final pollId = await _pollService.createPollWithOptions(
        poll: poll,
        options: options,
      );

      // üîî KIRIM NOTIFIKASI ke semua user
      await NotificationHelper.notifyNewPoll(
        pollId: pollId,
        pollTitle: poll.title,
        pollType: poll.type,
      );
      debugPrint('‚úÖ Poll notification sent to all users');

      _successMessage = 'Polling berhasil dibuat!';
      _isCreatingPoll = false;
      notifyListeners();

      return pollId;
    } catch (e) {
      _errorMessage = e.toString();
      _isCreatingPoll = false;
      notifyListeners();
      return null;
    }
  }

  // ===== VOTE OPERATIONS =====

  /// Submit vote
  Future<bool> submitVote({
    required String pollId,
    required String optionId,
    required String userId,
    required String userName,
    String? userPhoto,
    String? userRT,
    String? userRW,
    required String optionText,
    bool isAnonymous = false,
    Map<String, dynamic>? metadata,
  }) async {
    _isSubmittingVote = true;
    _errorMessage = null;
    notifyListeners();

    try {
      // Create PollVote object
      final vote = PollVote(
        voteId: '', // Will be auto-generated by Firestore
        pollId: pollId,
        optionId: optionId,
        userId: userId,
        userName: userName,
        userPhoto: userPhoto,
        userRT: userRT,
        userRW: userRW,
        optionText: optionText,
        votedAt: DateTime.now(),
        isAnonymous: isAnonymous,
        metadata: metadata ?? {},
      );

      await _pollService.submitVote(vote);

      _hasUserVoted = true;
      _successMessage = 'Vote berhasil dikirim!';
      _isSubmittingVote = false;
      notifyListeners();

      return true;
    } catch (e) {
      _errorMessage = e.toString();
      _isSubmittingVote = false;
      notifyListeners();
      return false;
    }
  }

  /// Check apakah user sudah vote
  Future<void> checkUserVoteStatus(String pollId, String userId) async {
    try {
      _hasUserVoted = await _pollService.hasUserVoted(pollId, userId);

      if (_hasUserVoted) {
        _userVote = await _pollService.getUserVote(pollId, userId);
      }

      notifyListeners();
    } catch (e) {
      if (kDebugMode) {
        print('Error checking vote status: $e');
      }
    }
  }

  // ===== STREAM SUBSCRIPTIONS =====

  /// Load active official polls
  void loadActiveOfficialPolls() {
    if (kDebugMode) {
      print('üó≥Ô∏è [PollProvider] Loading active official polls...');
    }

    _pollService.streamActivePolls(pollLevel: 'official').listen(
      (polls) {
        if (kDebugMode) {
          print('‚úÖ [PollProvider] Loaded ${polls.length} official polls');
          for (var poll in polls) {
            print('   - ${poll.title} (ID: ${poll.pollId})');
          }
        }
        _activeOfficialPolls = polls;
        notifyListeners();
      },
      onError: (error) {
        if (kDebugMode) {
          print('‚ùå [PollProvider] Error loading official polls: $error');
          if (error.toString().contains('index')) {
            print('   üî• INDEX ISSUE DETECTED!');
            print('   ‚Üí Firestore index masih building atau belum dibuat');
            print('   ‚Üí Check: https://console.firebase.google.com/project/pbl-2025-35a1c/firestore/indexes');
          }
        }
      },
    );
  }

  /// Load active community polls
  void loadActiveCommunityPolls() {
    if (kDebugMode) {
      print('üó≥Ô∏è [PollProvider] Loading active community polls...');
    }

    _pollService.streamActivePolls(pollLevel: 'community').listen(
      (polls) {
        if (kDebugMode) {
          print('‚úÖ [PollProvider] Loaded ${polls.length} community polls');
          for (var poll in polls) {
            print('   - ${poll.title} (ID: ${poll.pollId})');
          }
        }
        _activeCommunityPolls = polls;
        notifyListeners();
      },
      onError: (error) {
        if (kDebugMode) {
          print('‚ùå [PollProvider] Error loading community polls: $error');
          if (error.toString().contains('index')) {
            print('   üî• INDEX ISSUE DETECTED!');
            print('   ‚Üí Firestore index masih building atau belum dibuat');
          }
        }
      },
    );
  }

  /// Load my polls (created by user)
  void loadMyPolls(String userId) {
    _pollService.streamPolls(createdBy: userId).listen(
      (polls) {
        _myPolls = polls;
        notifyListeners();
      },
      onError: (error) {
        if (kDebugMode) {
          print('Error loading my polls: $error');
        }
      },
    );
  }

  /// Load poll detail dengan options dan votes
  void loadPollDetail(String pollId) {
    // Load poll
    _pollService.streamPollDetail(pollId).listen(
      (poll) {
        _currentPoll = poll;
        notifyListeners();
      },
      onError: (error) {
        _errorMessage = 'Gagal memuat detail polling';
        notifyListeners();
      },
    );

    // Load options (REAL-TIME untuk bar chart!)
    _pollService.streamPollOptions(pollId).listen(
      (options) {
        _currentOptions = options;
        notifyListeners();
      },
      onError: (error) {
        if (kDebugMode) {
          print('Error loading options: $error');
        }
      },
    );

    // Load votes
    _pollService.streamPollVotes(pollId).listen(
      (votes) {
        _currentVotes = votes;
        notifyListeners();
      },
      onError: (error) {
        if (kDebugMode) {
          print('Error loading votes: $error');
        }
      },
    );

    // Load results
    _pollService.streamPollResults(pollId).listen(
      (result) {
        _currentResult = result;
        notifyListeners();
      },
      onError: (error) {
        if (kDebugMode) {
          print('Error loading results: $error');
        }
      },
    );
  }

  // ===== UPDATE OPERATIONS =====

  /// Close poll
  Future<bool> closePoll(String pollId) async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      await _pollService.closePoll(pollId);

      // üîî KIRIM NOTIFIKASI hasil polling ke peserta
      try {
        // Use current loaded poll and votes data
        if (_currentPoll != null && _currentVotes.isNotEmpty) {
          final participantIds = _currentVotes
              .map((vote) => vote.userId)
              .toSet()
              .toList();

          await NotificationHelper.notifyPollResult(
            pollId: pollId,
            pollTitle: _currentPoll!.title,
            participantIds: participantIds,
          );
          debugPrint('‚úÖ Poll result notification sent to ${participantIds.length} participants');
        }
      } catch (e) {
        debugPrint('‚ö†Ô∏è Error sending poll result notification: $e');
      }

      _successMessage = 'Polling berhasil ditutup';
      _isLoading = false;
      notifyListeners();
      return true;
    } catch (e) {
      _errorMessage = e.toString();
      _isLoading = false;
      notifyListeners();
      return false;
    }
  }

  /// Pin/Unpin poll
  Future<bool> togglePinPoll(String pollId, bool isPinned) async {
    try {
      await _pollService.togglePinPoll(pollId, isPinned);
      _successMessage = isPinned ? 'Polling di-pin' : 'Polling di-unpin';
      notifyListeners();
      return true;
    } catch (e) {
      _errorMessage = e.toString();
      notifyListeners();
      return false;
    }
  }

  /// Delete poll
  Future<bool> deletePoll(String pollId) async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      await _pollService.deletePoll(pollId);
      _successMessage = 'Polling berhasil dihapus';
      _isLoading = false;

      // Remove from lists
      _activeOfficialPolls.removeWhere((p) => p.pollId == pollId);
      _activeCommunityPolls.removeWhere((p) => p.pollId == pollId);
      _myPolls.removeWhere((p) => p.pollId == pollId);

      notifyListeners();
      return true;
    } catch (e) {
      _errorMessage = e.toString();
      _isLoading = false;
      notifyListeners();
      return false;
    }
  }

  // ===== ADMIN METHODS (NO VOTING) =====

  /// Load poll for admin monitoring (READ-ONLY)
  /// Admin tidak bisa vote, hanya monitoring!
  void loadPollForAdminMonitoring(String pollId) {
    if (kDebugMode) {
      print('üëÆ [PollProvider] Admin monitoring poll: $pollId');
      print('   Admin CANNOT vote - read-only mode');
    }

    loadPollDetail(pollId);
  }

  /// Check if user is admin and should not be able to vote
  bool canUserVote(String userRole) {
    // Admin, Bendahara, Sekretaris TIDAK BISA VOTE
    final adminRoles = ['admin', 'bendahara', 'sekretaris'];
    return !adminRoles.contains(userRole.toLowerCase());
  }

  /// Get analytics data for admin dashboard
  Map<String, dynamic> getPollAnalytics() {
    if (_currentPoll == null || _currentOptions.isEmpty) {
      return {};
    }

    final totalVotes = _currentPoll!.totalVotes;
    final totalParticipants = _currentPoll!.totalParticipants;

    // Find winner
    final sortedOptions = List<PollOption>.from(_currentOptions)
      ..sort((a, b) => b.voteCount.compareTo(a.voteCount));

    final winner = sortedOptions.isNotEmpty ? sortedOptions.first : null;

    return {
      'totalVotes': totalVotes,
      'totalParticipants': totalParticipants,
      'totalOptions': _currentOptions.length,
      'winner': winner?.text,
      'winnerVotes': winner?.voteCount ?? 0,
      'winnerPercentage': winner?.percentage ?? 0.0,
      'optionsData': _currentOptions
          .map((o) => {
                'text': o.text,
                'votes': o.voteCount,
                'percentage': o.percentage,
              })
          .toList(),
    };
  }

  // ===== UTILITY METHODS =====

  /// Clear messages
  void clearMessages() {
    _errorMessage = null;
    _successMessage = null;
    notifyListeners();
  }

  /// Clear current poll data
  void clearCurrentPoll() {
    _currentPoll = null;
    _currentOptions = [];
    _currentVotes = [];
    _currentResult = null;
    _userVote = null;
    _hasUserVoted = false;
    notifyListeners();
  }

  /// Reset provider
  void reset() {
    _isLoading = false;
    _isSubmittingVote = false;
    _isCreatingPoll = false;
    _errorMessage = null;
    _successMessage = null;
    _currentPoll = null;
    _currentOptions = [];
    _currentVotes = [];
    _currentResult = null;
    _userVote = null;
    _hasUserVoted = false;
    _activeOfficialPolls = [];
    _activeCommunityPolls = [];
    _myPolls = [];
    _pollHistory = [];
    notifyListeners();
  }

  @override
  void dispose() {
    // Clean up jika ada subscription
    super.dispose();
  }
}

